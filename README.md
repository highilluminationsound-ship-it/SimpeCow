# Cow Controller

Простой, но функциональный AI-контроллер для коровы или другого животного в Unity. Вся логика содержится в одном скрипте `CowController.cs`.

## Общее описание

Наш проект представляет собой симуляцию жизни простого существа в мире Unity — коровы. В основе ее поведения лежит один-единственный, но мощный скрипт `CowController.cs`, который служит для нее мозгом и центральной нервной системой. Идея заключалась в том, чтобы создать автономного персонажа, чье поведение было бы предсказуемым, но в то же время достаточно живым и разнообразным, чтобы игрок мог поверить в его существование. Вся сложная логика инкапсулирована в этом одном файле, что делает управление и настройку коровы предельно простыми и понятными.

Сердцем скрипта является машина состояний — простой, но эффективный механизм, определяющий, что корова делает в каждый конкретный момент времени. У нее есть несколько ключевых "настроений". В состоянии покоя (`Idle`) она просто стоит на месте, отдыхая. Но долго бездельничать ей не свойственно, и через случайный промежуток времени она переходит в состояние ходьбы (`Walking`). В этом режиме она выбирает одну из заранее заданных точек на карте (waypoint) и неспешно движется к ней, создавая иллюзию осмысленного перемещения по пастбищу. Достигнув цели, она может либо снова впасть в "задумчивость", либо, если повезет, решить перекусить, перейдя в состояние еды (`Eating`). Однако мирная жизнь может быть прервана. При получении урона инстинкт самосохранения берет верх, и корова переключается в состояние бега (`Running`), спасаясь бегством в случайном направлении. Если же здоровье иссякнет, наступает финальное состояние — смерть, в котором корова падает, оставляя после себя небольшой "дроп".

Этот скрипт не работает в вакууме; он тесно взаимодействует со стандартными компонентами Unity, которые должны быть на том же игровом объекте. Он постоянно обращается к компоненту `Transform`, чтобы знать, где корова находится, и чтобы плавно поворачивать ее в сторону движения. Для самого передвижения используется `Rigidbody` — физическое тело коровы. Скрипт не телепортирует ее, а задает скорость этому компоненту, что позволяет ей естественно взаимодействовать с физикой мира: ходить по неровной поверхности и останавливаться перед препятствиями. В свою очередь, `Rigidbody` опирается на `CapsuleCollider`, который определяет физические границы объекта. Наконец, за визуальное воплощение всех действий отвечает `Animator`. Скрипт выступает в роли дирижера: когда корова идет, он говорит аниматору: "включи анимацию ходьбы", когда получает урон — "проиграй анимацию боли". Это позволяет легко подменять анимации или даже саму модель, не меняя ни строчки кода в логике поведения.

## Техническое описание и архитектура

В основе `CowController` лежит паттерн "Конечный автомат" (Finite State Machine, FSM), реализованный в рамках одного класса-наследника `MonoBehaviour`. Выбор FSM был обусловлен необходимостью управлять четко определенным и взаимоисключающим набором состояний (покой, ходьба, бег и т.д.). Такой подход позволяет избежать разрастания условных операторов в методе `Update()`, делая код более структурированным, читаемым и легко расширяемым. При инициализации в методе `Start()` происходит кэширование ссылок на ключевые компоненты (`Animator`, `Rigidbody`). Это стандартная практика оптимизации, позволяющая избежать многократных вызовов `GetComponent()` в каждом кадре, так как эта операция является относительно ресурсоемкой. Сразу после этого контроллер переводится в начальное состояние `Idle` и выставляется таймер для первой смены состояния, что обеспечивает предсказуемый и управляемый запуск AI.

Жизненный цикл AI управляется из метода `Update()`, который выступает в роли "тика" для нашего автомата. Центральным элементом здесь является конструкция `switch` по текущему состоянию `currentState`, которая делегирует выполнение логики кадра соответствующему приватному методу-обработчику (например, `HandleIdleState()`). Эти обработчики инкапсулируют всю логику, специфичную для конкретного состояния: в основном это работа с таймерами и проверка условий для перехода в другое состояние. Сам переход реализован через единый метод `SwitchState(newState)`. Такое решение позволяет централизовать логику смены состояний: в нем происходит корректное завершение предыдущего состояния (например, сброс булевых параметров в `Animator`) и инициализация нового (установка таймеров, выбор новой цели), что предотвращает дублирование кода и потенциальные ошибки при переходах.

За физическое перемещение отвечает `Rigidbody`. Вместо прямого манипулирования `transform.position`, что привело бы к игнорированию физики, мы работаем через `Rigidbody.velocity`. Такой подход передает контроль над перемещением физическому движку Unity (PhysX), обеспечивая корректную обработку столкновений, гравитации и взаимодействия с другими физическими объектами. Для ротации используется `Quaternion.Slerp`, который обеспечивает плавную интерполяцию к целевому направлению, что выглядит гораздо естественнее мгновенного поворота. Система навигации намеренно упрощена до массива `Transform` (waypoints), чтобы избежать издержек полноценного pathfinding'а через `NavMesh`, что соответствует требованию минимализма.

Взаимодействие с внешним миром реализовано через публичный метод `TakeDamage(float amount)`. Он служит единой точкой входа (API) для любых повреждающих систем, будь то оружие игрока или опасные зоны на карте. Это полностью отвязывает логику коровы от источника урона. При получении урона контроллер либо переходит в состояние `Running` для симуляции бегства, либо, при падении здоровья до нуля, инициирует терминальное состояние через вызов приватного метода `Die()`. Внутри `Die()` `Rigidbody` переводится в кинематический режим, а `Collider` отключается. Это критически важно, чтобы предотвратить нежелательные физические взаимодействия с мертвым телом. Уничтожение объекта `gameObject` происходит с задержкой, чтобы дать `Animator`'у время на полное проигрывание анимации смерти, обеспечивая визуальную целостность сцены.

## Инструкция по настройке

*--- ИНСТРУКЦИЯ ПО НАСТРОЙКЕ ---*
*1. Повесьте этот скрипт на ваш GameObject коровы.*

*2. Убедитесь, что на объекте коровы есть следующие компоненты:*
*   - Rigidbody (для физики, не ставьте isKinematic)*
*   - CapsuleCollider (или другой коллайдер для столкновений)*
*   - Animator (для проигрывания анимаций)*

*3. Создайте и настройте Animator Controller для коровы. Он должен содержать следующие параметры:*
*   - IsWalking (тип Bool)*
*   - IsRunning (тип Bool)*
*   - IsEating (тип Bool)*
*   - TakeDamage (тип Trigger)*
*   - Die (тип Trigger)*
*   Настройте переходы между анимациями (например, из Idle в Walk при IsWalking = true).*

*4. Настройте публичные поля в Инспекторе Unity, выбрав объект с этим скриптом:*
*   - Задайте скорость, здоровье и другие параметры в секции "Параметры коровы".*
*   - В секции "AI" создайте на сцене несколько пустых GameObject, которые будут служить точками маршрута,*
*     и перетащите их в массив "Waypoints".*
*   - В секции "Ссылки на компоненты и префабы" создайте префаб "мяса" и перетащите его в поле "Meat Prefab".*

*5. Чтобы нанести урон корове из другого скрипта, получите доступ к этому компоненту и вызовите метод TakeDamage().*
*   Пример кода для скрипта, наносящего урон (например, скрипт пули):*

*   void OnCollisionEnter(Collision collision)*
*   {*
*       CowController cow = collision.gameObject.GetComponent<CowController>();*
*       if (cow != null)*
*       {*
*           cow.TakeDamage(25f); // Наносим 25 урона*
*       }*
*   }*